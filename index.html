<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Focus">
<meta name="theme-color" content="#000000">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>Focus Blocks</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
    background: #000; color: #fff;
    min-height: 100dvh; display: flex; flex-direction: column; align-items: center;
    padding: 0 20px; -webkit-font-smoothing: antialiased; overflow-x: hidden;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(16px); }
    to { opacity: 1; transform: translateY(0); }
  }

  canvas#confettiCanvas { position: fixed; inset: 0; pointer-events: none; z-index: 100; }

  .header {
    width: 100%; max-width: 420px;
    padding-top: max(64px, env(safe-area-inset-top, 20px) + 44px);
    padding-bottom: 8px; text-align: center;
    animation: fadeIn 0.5s ease both;
  }
  .header-title {
    font-size: 12px; font-weight: 600; letter-spacing: 3px;
    text-transform: uppercase; color: rgba(255,255,255,0.35); margin-bottom: 6px;
  }
  .header-date {
    font-size: 13px; color: rgba(255,255,255,0.25);
    font-family: 'SF Mono', ui-monospace, monospace;
  }

  .tasks {
    width: 100%; max-width: 420px;
    display: flex; flex-direction: column; gap: 14px;
    padding: 20px 0 24px;
  }

  /* Task card */
  .task-card {
    border-radius: 24px; padding: 24px;
    border: 1px solid rgba(255,255,255,0.06);
    transition: all 0.4s cubic-bezier(0.16,1,0.3,1);
    animation: fadeIn 0.4s ease both;
    -webkit-user-select: none; user-select: none;
  }
  .task-card.completed {
    background: rgba(52,211,153,0.06) !important;
    border-color: rgba(52,211,153,0.25) !important;
  }

  .task-header {
    display: flex; align-items: center; justify-content: space-between;
    cursor: pointer;
  }
  .task-header:active { opacity: 0.8; }
  .task-left { display: flex; align-items: center; gap: 14px; }
  .task-emoji { font-size: 28px; }
  .task-info { display: flex; flex-direction: column; gap: 3px; }
  .task-label { font-size: 17px; font-weight: 600; transition: color 0.3s; }
  .task-label.completed { color: #34D399 !important; }
  .task-counter {
    font-size: 12px; color: rgba(255,255,255,0.3);
    font-family: 'SF Mono', ui-monospace, monospace; font-weight: 500;
  }
  .task-right { display: flex; align-items: center; gap: 10px; }

  /* Checkbox */
  .checkbox {
    width: 32px; height: 32px; border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.15);
    display: flex; align-items: center; justify-content: center;
    transition: all 0.3s ease; flex-shrink: 0;
  }
  .checkbox.checked { background: #34D399; border-color: #34D399; }
  .checkbox svg { opacity: 0; transition: opacity 0.2s ease; }
  .checkbox.checked svg { opacity: 1; }

  .subtask-badge {
    font-size: 11px; color: rgba(255,255,255,0.3);
    font-family: 'SF Mono', ui-monospace, monospace; font-weight: 600;
  }

  /* Subtask list */
  .subtask-list {
    max-height: 0; overflow: hidden;
    transition: max-height 0.4s ease, margin-top 0.3s ease, padding 0.3s ease;
    margin-top: 0;
  }
  .subtask-list.open { margin-top: 16px; max-height: 600px; }
  .subtask-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
    cursor: pointer;
  }
  .subtask-item:last-child { border-bottom: none; }
  .subtask-item:active { opacity: 0.7; }
  .subtask-name {
    font-size: 15px; font-weight: 500; color: rgba(255,255,255,0.75);
    transition: all 0.2s;
  }
  .subtask-name.done {
    color: #34D399; text-decoration: line-through;
    text-decoration-color: rgba(52,211,153,0.4);
  }
  .mini-check {
    width: 24px; height: 24px; border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.12);
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s; flex-shrink: 0;
  }
  .mini-check.checked { background: #34D399; border-color: #34D399; }
  .mini-check svg { opacity: 0; transition: opacity 0.15s; }
  .mini-check.checked svg { opacity: 1; }

  /* Bottom action bar */
  .bottom-bar {
    width: 100%; max-width: 420px;
    display: flex; gap: 10px;
    padding-bottom: max(40px, env(safe-area-inset-bottom, 20px) + 20px);
    animation: fadeIn 0.4s ease both;
  }
  .add-btn {
    flex: 1; border-radius: 24px;
    padding: 18px; border: 2px dashed rgba(255,255,255,0.08);
    background: none; color: rgba(255,255,255,0.25);
    font-size: 15px; font-weight: 600; font-family: inherit;
    cursor: pointer; display: flex; align-items: center;
    justify-content: center; gap: 8px; transition: all 0.2s;
  }
  .add-btn:active { border-color: rgba(255,255,255,0.2); color: rgba(255,255,255,0.5); }
  .manage-btn {
    border-radius: 24px; padding: 18px 20px;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.3);
    font-size: 15px; font-weight: 600; font-family: inherit;
    cursor: pointer; display: flex; align-items: center;
    justify-content: center; gap: 6px; transition: all 0.2s;
  }
  .manage-btn:active { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.5); }

  /* Edit picker modal */
  .edit-picker-list {
    padding: 0; list-style: none;
  }
  .edit-picker-item {
    display: flex; align-items: center; gap: 14px;
    padding: 16px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
    cursor: pointer; -webkit-user-select: none; user-select: none;
    transition: transform 0.25s cubic-bezier(0.2,0.8,0.2,1);
  }
  .edit-picker-item:last-child { border-bottom: none; }
  .edit-picker-item:active { opacity: 0.6; }
  .edit-picker-item.dragging {
    position: relative; z-index: 10;
    background: rgba(52,211,153,0.12);
    border-radius: 14px; padding: 16px 12px;
    border-bottom-color: transparent;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5), 0 2px 8px rgba(52,211,153,0.15);
    transform: scale(1.03);
    transition: box-shadow 0.2s, background 0.2s;
  }
  .edit-picker-item.dragging:active { opacity: 1; }
  .edit-picker-emoji { font-size: 24px; }
  .edit-picker-label { font-size: 16px; font-weight: 600; flex: 1; }
  .edit-picker-drag {
    background: none; border: none; color: rgba(255,255,255,0.2);
    font-size: 18px; cursor: grab; padding: 4px 8px;
    display: flex; align-items: center; justify-content: center;
    touch-action: none; margin-left: auto;
  }
  .edit-picker-drag:active { cursor: grabbing; color: rgba(255,255,255,0.5); }

  /* Modal overlay */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7);
    z-index: 50; opacity: 0; pointer-events: none;
    transition: opacity 0.3s;
  }
  .modal-overlay.visible { opacity: 1; pointer-events: all; }

  /* Modal */
  .modal {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: #1C1C1E; border-radius: 20px 20px 0 0;
    z-index: 60; transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.32,0.72,0,1);
    max-height: 85vh; overflow-y: auto;
    padding: 0 24px max(30px, env(safe-area-inset-bottom, 20px));
  }
  .modal.visible { transform: translateY(0); }
  .modal-handle {
    width: 36px; height: 5px; border-radius: 3px;
    background: rgba(255,255,255,0.2); margin: 10px auto 0;
  }
  .modal-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 20px 0 16px;
  }
  .modal-title { font-size: 20px; font-weight: 700; }
  .modal-close {
    background: rgba(255,255,255,0.1); border: none;
    color: rgba(255,255,255,0.6); width: 32px; height: 32px;
    border-radius: 50%; font-size: 16px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }

  .form-label {
    font-size: 12px; font-weight: 600; letter-spacing: 1px;
    text-transform: uppercase; color: rgba(255,255,255,0.4);
    margin-bottom: 8px; margin-top: 20px;
  }
  .form-input {
    width: 100%; padding: 14px 16px; border-radius: 14px;
    background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08);
    color: #fff; font-size: 16px; font-family: inherit;
    outline: none;
  }
  .form-input:focus { border-color: rgba(255,255,255,0.2); }
  .form-input::placeholder { color: rgba(255,255,255,0.25); }

  /* Emoji picker */
  .emoji-grid {
    display: flex; flex-wrap: wrap; gap: 8px;
  }
  .emoji-option {
    width: 44px; height: 44px; border-radius: 12px;
    background: rgba(255,255,255,0.06); border: 2px solid transparent;
    font-size: 22px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
  }
  .emoji-option.selected { border-color: #34D399; background: rgba(52,211,153,0.15); }
  .emoji-option:active { transform: scale(0.9); }

  /* Color picker */
  .color-grid { display: flex; gap: 10px; flex-wrap: wrap; }
  .color-option {
    width: 36px; height: 36px; border-radius: 50%;
    border: 3px solid transparent; cursor: pointer;
    transition: all 0.2s; position: relative;
  }
  .color-option.selected { border-color: #fff; transform: scale(1.15); }
  .color-option:active { transform: scale(0.9); }

  /* Subtask form */
  .subtask-form { display: flex; gap: 8px; }
  .subtask-form input { flex: 1; }
  .subtask-add-btn {
    padding: 14px 16px; border-radius: 14px;
    background: rgba(255,255,255,0.1); border: none;
    color: #fff; font-size: 14px; font-weight: 600;
    font-family: inherit; cursor: pointer; white-space: nowrap;
  }
  .subtask-add-btn:active { opacity: 0.7; }

  .subtask-edit-list { margin-top: 10px; }
  .subtask-edit-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
  }
  .subtask-edit-item:last-child { border-bottom: none; }
  .subtask-edit-name { font-size: 15px; color: rgba(255,255,255,0.7); flex: 1; }
  .subtask-edit-actions { display: flex; align-items: center; gap: 2px; }
  .subtask-drag {
    background: none; border: none; color: rgba(255,255,255,0.2);
    font-size: 18px; cursor: grab; padding: 4px 8px;
    display: flex; align-items: center; justify-content: center;
    touch-action: none;
  }
  .subtask-drag:active { cursor: grabbing; color: rgba(255,255,255,0.5); }
  .subtask-remove {
    background: none; border: none; color: rgba(255,255,255,0.25);
    font-size: 18px; cursor: pointer; padding: 4px 8px;
  }
  .subtask-remove:active { color: #F43F5E; }
  .subtask-edit-item {
    transition: transform 0.25s cubic-bezier(0.2,0.8,0.2,1);
  }
  .subtask-edit-item.dragging {
    position: relative; z-index: 10;
    background: rgba(52,211,153,0.12);
    border-radius: 14px;
    border-bottom-color: transparent;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5), 0 2px 8px rgba(52,211,153,0.15);
    transform: scale(1.04);
    transition: box-shadow 0.2s, background 0.2s;
  }

  /* Counter edit */
  .counter-row {
    display: flex; align-items: center; gap: 12px;
  }
  .counter-btn {
    width: 40px; height: 40px; border-radius: 12px;
    background: rgba(255,255,255,0.08); border: none;
    color: #fff; font-size: 20px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }
  .counter-btn:active { background: rgba(255,255,255,0.15); }
  .counter-value {
    font-size: 20px; font-weight: 700; min-width: 30px; text-align: center;
    font-family: 'SF Mono', ui-monospace, monospace;
  }

  /* Action buttons */
  .modal-actions { display: flex; gap: 10px; margin-top: 24px; padding-bottom: 8px; }
  .btn-save {
    flex: 1; padding: 16px; border-radius: 16px;
    background: #34D399; color: #000; border: none;
    font-size: 16px; font-weight: 700; font-family: inherit; cursor: pointer;
  }
  .btn-save:active { opacity: 0.8; }
  .btn-delete {
    padding: 16px 20px; border-radius: 16px;
    background: rgba(244,63,94,0.15); color: #F43F5E; border: none;
    font-size: 16px; font-weight: 700; font-family: inherit; cursor: pointer;
  }
  .btn-delete:active { opacity: 0.8; }
</style>
</head>
<body>

<canvas id="confettiCanvas"></canvas>

<div class="header">
  <div class="header-title">Focus Blocks</div>
  <div class="header-date" id="headerDate"></div>
</div>

<div class="tasks" id="tasksContainer"></div>

<div class="bottom-bar">
  <button class="add-btn" onclick="openModal()">ï¼‹ Neuer Task</button>
  <button class="manage-btn" onclick="openEditPicker()">âœŽ</button>
</div>

<!-- Edit picker overlay -->
<div class="modal-overlay" id="editPickerOverlay" onclick="closeEditPicker()"></div>
<div class="modal" id="editPickerModal">
  <div class="modal-handle"></div>
  <div class="modal-header">
    <span class="modal-title">Task bearbeiten</span>
    <button class="modal-close" onclick="closeEditPicker()">âœ•</button>
  </div>
  <div class="edit-picker-list" id="editPickerList"></div>
</div>

<!-- Modal overlay -->
<div class="modal-overlay" id="modalOverlay" onclick="closeModal()"></div>

<!-- Modal -->
<div class="modal" id="modal">
  <div class="modal-handle"></div>
  <div class="modal-header">
    <span class="modal-title" id="modalTitle">Neuer Task</span>
    <button class="modal-close" onclick="closeModal()">âœ•</button>
  </div>

  <div class="form-label">Emoji</div>
  <div class="emoji-grid" id="emojiGrid"></div>

  <div class="form-label">Name</div>
  <input class="form-input" id="inputName" placeholder="Task-Name..." maxlength="30">

  <div class="form-label">Farbe</div>
  <div class="color-grid" id="colorGrid"></div>

  <div class="form-label">Subtasks (optional)</div>
  <div class="subtask-form">
    <input class="form-input" id="inputSubtask" placeholder="Subtask hinzufÃ¼gen...">
    <button class="subtask-add-btn" onclick="addSubtaskToForm()">+</button>
  </div>
  <div class="subtask-edit-list" id="subtaskEditList"></div>

  <div class="form-label" id="counterLabel" style="display:none">Absolviert</div>
  <div class="counter-row" id="counterRow" style="display:none">
    <button class="counter-btn" onclick="adjustCounter(-1)">âˆ’</button>
    <span class="counter-value" id="counterValue">0</span>
    <button class="counter-btn" onclick="adjustCounter(1)">+</button>
  </div>

  <div class="modal-actions">
    <button class="btn-save" onclick="saveTask()">Speichern</button>
    <button class="btn-delete" id="btnDelete" style="display:none" onclick="deleteTask()">LÃ¶schen</button>
  </div>
</div>

<script>
// --- Config ---
const EMOJIS = ['ðŸ§˜','ðŸ”­','ðŸ”¥','ðŸ¤¸','ðŸ“š','ðŸ’ª','ðŸŽ¯','ðŸƒ','ðŸ§ ','ðŸ’»','ðŸŽ¨','ðŸŽµ','âœï¸','ðŸ‹ï¸','ðŸš€','â˜•','ðŸŒ…','ðŸ’¤'];
const COLORS = [
  { color:'#8B5CF6', bg:'rgba(139,92,246,0.08)' },
  { color:'#F59E0B', bg:'rgba(245,158,11,0.08)' },
  { color:'#06B6D4', bg:'rgba(6,182,212,0.08)' },
  { color:'#10B981', bg:'rgba(16,185,129,0.08)' },
  { color:'#EC4899', bg:'rgba(236,72,153,0.08)' },
  { color:'#F43F5E', bg:'rgba(244,63,94,0.08)' },
];

const DEFAULT_TASKS = [
  { id:'meditate', label:'Meditieren', emoji:'ðŸ§˜', color:'#8B5CF6', bg:'rgba(139,92,246,0.08)', completed:false, counter:0, subtasks:[] },
  { id:'neighbor', label:'Nachbars Dilemma', emoji:'ðŸ”­', color:'#F59E0B', bg:'rgba(245,158,11,0.08)', completed:false, counter:0, subtasks:[] },
  { id:'work', label:'Crazy Work', emoji:'ðŸ”¥', color:'#06B6D4', bg:'rgba(6,182,212,0.08)', completed:false, counter:0, subtasks:[] },
  { id:'stretches', label:'Stretches', emoji:'ðŸ¤¸', color:'#10B981', bg:'rgba(16,185,129,0.08)', completed:false, counter:0,
    subtasks:[
      { name:'Hamstring Stretch', completed:false },
      { name:'Hip Flexor', completed:false },
      { name:'Quad Stretch', completed:false },
      { name:'Shoulder Stretch', completed:false },
      { name:'Cat-Cow', completed:false },
    ]
  },
];

// --- State ---
let tasks = loadTasks();
let openAccordion = null; // index of open accordion
let editingIndex = null; // null = creating, number = editing
let formSubtasks = [];
let formCounter = 0;

// --- localStorage ---
function loadTasks() {
  try {
    const saved = JSON.parse(localStorage.getItem('focusTasksV2'));
    if (saved && saved.length > 0) return saved;
  } catch {}
  return JSON.parse(JSON.stringify(DEFAULT_TASKS));
}

function saveTasks() {
  localStorage.setItem('focusTasksV2', JSON.stringify(tasks));
}

// --- Daily reset ---
function checkDailyReset() {
  const today = new Date().toDateString();
  const lastReset = localStorage.getItem('focusLastReset');
  if (lastReset !== today) {
    tasks.forEach(t => {
      t.completed = false;
      if (t.subtasks) t.subtasks.forEach(s => s.completed = false);
    });
    saveTasks();
    localStorage.setItem('focusLastReset', today);
  }
}
checkDailyReset();

// --- Date ---
document.getElementById('headerDate').textContent =
  new Date().toLocaleDateString('de-CH', { weekday:'long', day:'numeric', month:'long' });

// --- Confetti ---
const cCanvas = document.getElementById('confettiCanvas');
const cCtx = cCanvas.getContext('2d');
let cParticles = [];
let cAnimId = null;
function resizeCanvas() { cCanvas.width = window.innerWidth; cCanvas.height = window.innerHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const CONFETTI_COLORS = ['#34D399','#8B5CF6','#F59E0B','#06B6D4','#EC4899','#F43F5E','#A78BFA','#FBBF24'];

function fireConfetti(x, y) {
  cParticles = [];
  for (let i = 0; i < 120; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 3 + Math.random() * 9;
    cParticles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 4,
      size: 4 + Math.random() * 5,
      color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
      rotation: Math.random() * 360,
      rotSpeed: (Math.random() - 0.5) * 12,
      gravity: 0.12 + Math.random() * 0.08,
      opacity: 1,
      shape: Math.random() > 0.5 ? 'rect' : 'circle',
    });
  }
  if (cAnimId) cancelAnimationFrame(cAnimId);
  animateConfetti();
}

function animateConfetti() {
  cCtx.clearRect(0, 0, cCanvas.width, cCanvas.height);
  let alive = false;
  cParticles.forEach(p => {
    p.x += p.vx; p.y += p.vy;
    p.vy += p.gravity; p.vx *= 0.99;
    p.rotation += p.rotSpeed; p.opacity -= 0.009;
    if (p.opacity <= 0) return;
    alive = true;
    cCtx.save();
    cCtx.translate(p.x, p.y);
    cCtx.rotate(p.rotation * Math.PI / 180);
    cCtx.globalAlpha = p.opacity;
    cCtx.fillStyle = p.color;
    if (p.shape === 'rect') cCtx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
    else { cCtx.beginPath(); cCtx.arc(0, 0, p.size/2, 0, Math.PI*2); cCtx.fill(); }
    cCtx.restore();
  });
  if (alive) cAnimId = requestAnimationFrame(animateConfetti);
}

function haptic() { try { navigator.vibrate(10); } catch {} }

// --- Render ---
function render() {
  const container = document.getElementById('tasksContainer');
  container.innerHTML = '';
  tasks.forEach((t, i) => {
    const hasSubtasks = t.subtasks && t.subtasks.length > 0;
    const isOpen = openAccordion === i;
    const doneCount = hasSubtasks ? t.subtasks.filter(s => s.completed).length : 0;
    const totalCount = hasSubtasks ? t.subtasks.length : 0;

    const card = document.createElement('div');
    card.className = 'task-card' + (t.completed ? ' completed' : '');
    card.style.background = t.completed ? '' : t.bg;
    card.id = 'card' + i;

    const subLabel = hasSubtasks ? `<span class="subtask-badge">${doneCount}/${totalCount}</span>` : '';
    const rightHtml = `
      ${subLabel}
      <div class="checkbox${t.completed ? ' checked' : ''}" id="check${i}">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
      </div>`;

    let subtaskHtml = '';
    if (hasSubtasks) {
      const items = t.subtasks.map((s, si) => `
        <div class="subtask-item" onclick="event.stopPropagation(); toggleSubtask(${i}, ${si})">
          <span class="subtask-name${s.completed ? ' done' : ''}">${s.name}</span>
          <div class="mini-check${s.completed ? ' checked' : ''}">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="3" stroke-linecap="round"><polyline points="20 6 9 17 4 12"/></svg>
          </div>
        </div>`).join('');
      subtaskHtml = `<div class="subtask-list${isOpen ? ' open' : ''}">${items}</div>`;
    }

    card.innerHTML = `
      <div>
        <div class="task-header" onclick="handleTaskClick(${i})">
          <div class="task-left">
            <span class="task-emoji">${t.emoji}</span>
            <div class="task-info">
              <span class="task-label${t.completed ? ' completed' : ''}" style="color:${t.completed ? '#34D399' : t.color}">${t.label}</span>
              <span class="task-counter">${t.counter}Ã— absolviert</span>
            </div>
          </div>
          <div class="task-right">${rightHtml}</div>
        </div>
        ${subtaskHtml}
      </div>`;
    container.appendChild(card);
  });
}

// --- Task interactions ---
function handleTaskClick(i) {
  const t = tasks[i];
  const hasSubtasks = t.subtasks && t.subtasks.length > 0;

  if (hasSubtasks) {
    if (t.completed) {
      // Reopen: uncheck all subtasks, uncomplete task
      t.completed = false;
      t.subtasks.forEach(s => s.completed = false);
      openAccordion = i;
      saveTasks(); render();
    } else {
      openAccordion = openAccordion === i ? null : i;
      render();
    }
  } else {
    // Simple toggle
    const wasCompleted = t.completed;
    t.completed = !t.completed;
    if (t.completed) {
      t.counter++;
      haptic();
      saveTasks(); render();
      triggerConfettiOnCard(i);
    } else {
      saveTasks(); render();
    }
  }
}

function toggleSubtask(taskIdx, subIdx) {
  const t = tasks[taskIdx];
  t.subtasks[subIdx].completed = !t.subtasks[subIdx].completed;
  haptic();

  // Check if all done
  const allDone = t.subtasks.every(s => s.completed);
  if (allDone) {
    t.completed = true;
    t.counter++;
    openAccordion = null;
    saveTasks(); render();
    setTimeout(() => triggerConfettiOnCard(taskIdx), 300);
  } else {
    t.completed = false;
    saveTasks(); render();
  }
}

function triggerConfettiOnCard(i) {
  const check = document.getElementById('check' + i);
  if (!check) return;
  const rect = check.getBoundingClientRect();
  fireConfetti(rect.left + rect.width / 2, rect.top + rect.height / 2);
}

// --- Modal ---
function openModal(index) {
  editingIndex = typeof index === 'number' ? index : null;
  const isEdit = editingIndex !== null;
  const t = isEdit ? tasks[editingIndex] : null;

  document.getElementById('modalTitle').textContent = isEdit ? 'Task bearbeiten' : 'Neuer Task';
  document.getElementById('inputName').value = isEdit ? t.label : '';
  document.getElementById('btnDelete').style.display = isEdit ? '' : 'none';
  document.getElementById('counterLabel').style.display = isEdit ? '' : 'none';
  document.getElementById('counterRow').style.display = isEdit ? 'flex' : 'none';

  formSubtasks = isEdit && t.subtasks ? t.subtasks.map(s => s.name) : [];
  formCounter = isEdit ? t.counter : 0;
  document.getElementById('counterValue').textContent = formCounter;

  // Build emoji grid
  const selEmoji = isEdit ? t.emoji : EMOJIS[0];
  document.getElementById('emojiGrid').innerHTML = EMOJIS.map(e =>
    `<div class="emoji-option${e === selEmoji ? ' selected' : ''}" onclick="selectEmoji(this, '${e}')">${e}</div>`
  ).join('');

  // Build color grid
  const selColor = isEdit ? t.color : COLORS[0].color;
  document.getElementById('colorGrid').innerHTML = COLORS.map(c =>
    `<div class="color-option${c.color === selColor ? ' selected' : ''}" style="background:${c.color}" data-color-value="${c.color}" onclick="selectColor(this, '${c.color}')"></div>`
  ).join('');

  renderFormSubtasks();
  document.getElementById('inputSubtask').value = '';
  document.getElementById('modalOverlay').classList.add('visible');
  document.getElementById('modal').classList.add('visible');
}

function closeModal() {
  document.getElementById('modalOverlay').classList.remove('visible');
  document.getElementById('modal').classList.remove('visible');
  editingIndex = null;
}

function selectEmoji(el, emoji) {
  document.querySelectorAll('.emoji-option').forEach(e => e.classList.remove('selected'));
  el.classList.add('selected');
}

function addSubtaskToForm() {
  const input = document.getElementById('inputSubtask');
  const name = input.value.trim();
  if (!name) return;
  formSubtasks.push(name);
  input.value = '';
  renderFormSubtasks();
}

function removeFormSubtask(idx) {
  formSubtasks.splice(idx, 1);
  renderFormSubtasks();
}

function renderFormSubtasks() {
  const list = document.getElementById('subtaskEditList');
  list.innerHTML = formSubtasks.map((s, i) =>
    `<div class="subtask-edit-item" data-idx="${i}">
      <span class="subtask-edit-name">${s}</span>
      <div class="subtask-edit-actions">
        <span class="subtask-drag" data-drag="${i}">â ¿</span>
        <button class="subtask-remove" onclick="removeFormSubtask(${i})">âœ•</button>
      </div>
    </div>`
  ).join('');
  initDragHandles();
}

// --- Touch drag & drop for subtasks (iOS Lift & Drag) ---
let dragCurrentIdx = null;
let dragStartY = 0;
let dragItemHeight = 0;
let dragOffsetY = 0;
let dragElement = null;

function initDragHandles() {
  document.querySelectorAll('.subtask-drag').forEach(handle => {
    handle.addEventListener('touchstart', onDragStart, { passive: false });
    handle.addEventListener('mousedown', onDragStartMouse);
  });
}

function onDragStartMouse(e) {
  dragCurrentIdx = parseInt(e.target.dataset.drag);
  dragStartY = e.clientY;
  setupDrag();
  document.addEventListener('mousemove', onDragMoveMouse);
  document.addEventListener('mouseup', onDragEnd);
}

function onDragStart(e) {
  e.preventDefault();
  dragCurrentIdx = parseInt(e.target.dataset.drag);
  dragStartY = e.touches[0].clientY;
  setupDrag();
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);
}

function setupDrag() {
  const items = document.querySelectorAll('.subtask-edit-item');
  if (items.length === 0) return;
  dragItemHeight = items[0].getBoundingClientRect().height;
  dragElement = items[dragCurrentIdx];
  dragOffsetY = 0;
  // Apply lift effect
  dragElement.classList.add('dragging');
  // Disable transitions on dragged item for smooth following
  dragElement.style.transition = 'box-shadow 0.2s, background 0.2s';
  haptic();
}

function onDragMove(e) {
  e.preventDefault();
  handleDragMove(e.touches[0].clientY);
}

function onDragMoveMouse(e) {
  handleDragMove(e.clientY);
}

function handleDragMove(clientY) {
  if (dragCurrentIdx === null || !dragElement) return;
  const diff = clientY - dragStartY;

  // Move dragged element visually following the finger
  dragOffsetY = diff;
  dragElement.style.transform = `scale(1.04) translateY(${diff}px)`;

  const threshold = dragItemHeight * 0.5;

  if (diff > threshold && dragCurrentIdx < formSubtasks.length - 1) {
    // Swap down
    swapItems(dragCurrentIdx, dragCurrentIdx + 1);
    dragCurrentIdx++;
    dragStartY = clientY;
    dragOffsetY = 0;
    haptic();
  } else if (diff < -threshold && dragCurrentIdx > 0) {
    // Swap up
    swapItems(dragCurrentIdx, dragCurrentIdx - 1);
    dragCurrentIdx--;
    dragStartY = clientY;
    dragOffsetY = 0;
    haptic();
  }
}

function swapItems(fromIdx, toIdx) {
  // Swap in data
  const tmp = formSubtasks[fromIdx];
  formSubtasks[fromIdx] = formSubtasks[toIdx];
  formSubtasks[toIdx] = tmp;

  // Swap DOM nodes instead of re-rendering (keeps drag alive)
  const list = document.getElementById('subtaskEditList');
  const items = Array.from(list.children);
  const otherItem = items[toIdx];

  if (otherItem) {
    // Animate other item shifting
    const direction = toIdx > fromIdx ? -1 : 1;
    otherItem.style.transition = 'none';
    otherItem.style.transform = `translateY(${direction * dragItemHeight}px)`;
    requestAnimationFrame(() => {
      otherItem.style.transition = 'transform 0.25s cubic-bezier(0.2,0.8,0.2,1)';
      otherItem.style.transform = 'translateY(0)';
    });

    // Actually swap DOM positions
    if (toIdx > fromIdx) {
      list.insertBefore(dragElement, otherItem.nextSibling);
    } else {
      list.insertBefore(dragElement, otherItem);
    }
  }
}

function onDragEnd() {
  if (dragElement) {
    // Settle animation: scale back to normal
    dragElement.style.transition = 'all 0.25s cubic-bezier(0.2,0.8,0.2,1)';
    dragElement.style.transform = 'scale(1) translateY(0)';
    dragElement.classList.remove('dragging');
  }
  dragCurrentIdx = null;
  dragElement = null;
  dragOffsetY = 0;
  document.removeEventListener('touchmove', onDragMove);
  document.removeEventListener('touchend', onDragEnd);
  document.removeEventListener('mousemove', onDragMoveMouse);
  document.removeEventListener('mouseup', onDragEnd);
  // Clean re-render after settle animation to sync data-idx attributes
  setTimeout(() => renderFormSubtasks(), 300);
}

function adjustCounter(delta) {
  formCounter = Math.max(0, formCounter + delta);
  document.getElementById('counterValue').textContent = formCounter;
}

function saveTask() {
  const name = document.getElementById('inputName').value.trim();
  if (!name) { document.getElementById('inputName').focus(); return; }

  const selEmoji = document.querySelector('.emoji-option.selected');
  const selColor = document.querySelector('.color-option.selected');
  const emoji = selEmoji ? selEmoji.textContent : 'ðŸŽ¯';
  const colorHex = selColor ? selColor.dataset.colorValue : COLORS[0].color;
  const colorObj = COLORS.find(c => c.color === colorHex) || COLORS[0];
  const finalColor = colorObj.color;
  const finalBg = colorObj.bg;

  if (editingIndex !== null) {
    // Update existing
    const t = tasks[editingIndex];
    t.label = name;
    t.emoji = emoji;
    t.color = finalColor;
    t.bg = finalBg;
    t.counter = formCounter;
    // Update subtasks: keep completion state for existing ones
    const oldNames = t.subtasks ? t.subtasks.map(s => s.name) : [];
    t.subtasks = formSubtasks.map(sName => {
      const oldIdx = oldNames.indexOf(sName);
      return { name: sName, completed: oldIdx >= 0 ? t.subtasks[oldIdx].completed : false };
    });
    // If subtasks changed, re-evaluate completion
    if (t.subtasks.length > 0) {
      t.completed = t.subtasks.every(s => s.completed);
    }
  } else {
    // Create new
    tasks.push({
      id: 'task_' + Date.now(),
      label: name,
      emoji,
      color: finalColor,
      bg: finalBg,
      completed: false,
      counter: 0,
      subtasks: formSubtasks.map(s => ({ name: s, completed: false })),
    });
  }

  saveTasks();
  closeModal();
  render();
}

function deleteTask() {
  if (editingIndex === null) return;
  if (!confirm('Task "' + tasks[editingIndex].label + '" wirklich lÃ¶schen?')) return;
  tasks.splice(editingIndex, 1);
  if (openAccordion === editingIndex) openAccordion = null;
  else if (openAccordion > editingIndex) openAccordion--;
  saveTasks();
  closeModal();
  render();
}

// Handle enter key in subtask input
document.getElementById('inputSubtask').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); addSubtaskToForm(); }
});

function selectColor(el, color) {
  document.querySelectorAll('.color-option').forEach(e => e.classList.remove('selected'));
  el.classList.add('selected');
  el.dataset.colorValue = color;
}

// --- Edit picker ---
let taskDragIdx = null;
let taskDragStartY = 0;
let taskDragItemH = 0;
let taskDragEl = null;

function openEditPicker() {
  renderEditPicker();
  document.getElementById('editPickerOverlay').classList.add('visible');
  document.getElementById('editPickerModal').classList.add('visible');
}

function renderEditPicker() {
  const list = document.getElementById('editPickerList');
  list.innerHTML = tasks.map((t, i) =>
    `<div class="edit-picker-item" data-tidx="${i}" onclick="onPickerItemTap(${i})">
      <span class="edit-picker-emoji">${t.emoji}</span>
      <span class="edit-picker-label" style="color:${t.color}">${t.label}</span>
      <span class="edit-picker-drag" data-tdrag="${i}">â ¿</span>
    </div>`
  ).join('');
  initTaskDragHandles();
}

function onPickerItemTap(i) {
  // Only open edit if not dragging
  if (taskDragIdx !== null) return;
  closeEditPicker();
  setTimeout(() => openModal(i), 300);
}

function closeEditPicker() {
  document.getElementById('editPickerOverlay').classList.remove('visible');
  document.getElementById('editPickerModal').classList.remove('visible');
}

function initTaskDragHandles() {
  document.querySelectorAll('.edit-picker-drag').forEach(handle => {
    handle.addEventListener('touchstart', onTaskDragStart, { passive: false });
    handle.addEventListener('mousedown', onTaskDragStartMouse);
  });
}

function onTaskDragStartMouse(e) {
  e.stopPropagation();
  taskDragIdx = parseInt(e.target.dataset.tdrag);
  taskDragStartY = e.clientY;
  setupTaskDrag();
  document.addEventListener('mousemove', onTaskDragMoveMouse);
  document.addEventListener('mouseup', onTaskDragEnd);
}

function onTaskDragStart(e) {
  e.preventDefault(); e.stopPropagation();
  taskDragIdx = parseInt(e.target.dataset.tdrag);
  taskDragStartY = e.touches[0].clientY;
  setupTaskDrag();
  document.addEventListener('touchmove', onTaskDragMove, { passive: false });
  document.addEventListener('touchend', onTaskDragEnd);
}

function setupTaskDrag() {
  const items = document.querySelectorAll('.edit-picker-item');
  if (items.length === 0) return;
  taskDragItemH = items[0].getBoundingClientRect().height;
  taskDragEl = items[taskDragIdx];
  taskDragEl.classList.add('dragging');
  taskDragEl.style.transition = 'box-shadow 0.2s, background 0.2s';
  haptic();
}

function onTaskDragMove(e) { e.preventDefault(); handleTaskDragMove(e.touches[0].clientY); }
function onTaskDragMoveMouse(e) { handleTaskDragMove(e.clientY); }

function handleTaskDragMove(clientY) {
  if (taskDragIdx === null || !taskDragEl) return;
  const diff = clientY - taskDragStartY;
  taskDragEl.style.transform = `scale(1.03) translateY(${diff}px)`;

  const threshold = taskDragItemH * 0.5;
  if (diff > threshold && taskDragIdx < tasks.length - 1) {
    swapTaskItems(taskDragIdx, taskDragIdx + 1);
    taskDragIdx++;
    taskDragStartY = clientY;
    haptic();
  } else if (diff < -threshold && taskDragIdx > 0) {
    swapTaskItems(taskDragIdx, taskDragIdx - 1);
    taskDragIdx--;
    taskDragStartY = clientY;
    haptic();
  }
}

function swapTaskItems(fromIdx, toIdx) {
  // Swap in tasks array
  const tmp = tasks[fromIdx];
  tasks[fromIdx] = tasks[toIdx];
  tasks[toIdx] = tmp;

  // Update openAccordion if needed
  if (openAccordion === fromIdx) openAccordion = toIdx;
  else if (openAccordion === toIdx) openAccordion = fromIdx;

  // Swap DOM nodes
  const list = document.getElementById('editPickerList');
  const items = Array.from(list.children);
  const otherItem = items[toIdx];
  if (otherItem) {
    const direction = toIdx > fromIdx ? -1 : 1;
    otherItem.style.transition = 'none';
    otherItem.style.transform = `translateY(${direction * taskDragItemH}px)`;
    requestAnimationFrame(() => {
      otherItem.style.transition = 'transform 0.25s cubic-bezier(0.2,0.8,0.2,1)';
      otherItem.style.transform = 'translateY(0)';
    });
    if (toIdx > fromIdx) {
      list.insertBefore(taskDragEl, otherItem.nextSibling);
    } else {
      list.insertBefore(taskDragEl, otherItem);
    }
  }
}

function onTaskDragEnd() {
  if (taskDragEl) {
    taskDragEl.style.transition = 'all 0.25s cubic-bezier(0.2,0.8,0.2,1)';
    taskDragEl.style.transform = 'scale(1) translateY(0)';
    taskDragEl.classList.remove('dragging');
  }
  taskDragIdx = null;
  taskDragEl = null;
  document.removeEventListener('touchmove', onTaskDragMove);
  document.removeEventListener('touchend', onTaskDragEnd);
  document.removeEventListener('mousemove', onTaskDragMoveMouse);
  document.removeEventListener('mouseup', onTaskDragEnd);
  // Save new order & re-render
  saveTasks();
  render();
  setTimeout(() => renderEditPicker(), 300);
}

// --- Init ---
render();
</script>
</body>
</html>